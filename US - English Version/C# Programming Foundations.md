# C# Fundamentals

 Repository of foundation projects in the C# language

# Questions and Answers

## 1. C# is a compiled, typed and managed language, what does this mean?
C# is a compiled, typed and managed language. This means:
- **Compiled**: The source code written in C# is transformed into intermediate code (IL - Intermediate Language) by the compiler. This intermediate code is then compiled at runtime into machine code by the CLR (Common Language Runtime).
- **Typed**: C# is a strongly typed language, which means that all variables and objects must have a declared type (int, string, etc.). This allows many errors to be detected at compile time.
- **Managed**: Code execution is managed by the CLR, which takes care of tasks such as garbage collection, security, and memory management.

## 2. What differentiates a compiled language from an interpreted one?
- **Compiled Language**: The source code is transformed into machine code before execution. Examples: C#, C++, Java.
- **Interpreted Language**: The code is executed line by line by an interpreter at runtime. Examples: Python, JavaScript, Ruby.
- **Advantages of Compiled**: Generally better performance due to prior translation into machine code.
- **Advantages of Interpreted**: Flexibility and ease of debugging, as the code is executed directly.

## 3. Explain how C# works
C# works as follows:
1. The source code is written in .cs files.
2. The C# compiler (csc) compiles the source code into IL (Intermediate Language).
3. The IL is stored in an assembly (DLL or EXE).
4. At runtime, the CLR (Common Language Runtime) compiles the IL to native machine code.
5. The CLR manages the execution of the code, including garbage collection, security, and performance optimizations.

## 4. What is the CLR?
The Common Language Runtime (CLR) is the .NET platform's virtual machine that manages the execution of programs written in various languages supported by .NET. Its main responsibilities include:
- JIT (Just-In-Time) compilation of IL to native code.
- Memory management and garbage collection.
- Security and type checking.
- Support for exceptions and debugging.

## 5. what is IL?
Intermediate Language (IL) is a set of low-level instructions generated by the .NET language compiler (such as C#). IL is platform-independent and is converted into native code by the CLR during execution. It allows different .NET languages to interact and share libraries.

## 6. What is a Framework?
A framework is a reusable software structure that provides a basis on which specific applications can be developed. It includes code libraries, APIs, tools and components that facilitate software development and integration. Examples include .NET Framework, Angular, and Spring.

## 7. What is .NET?
.NET is a software development platform created by Microsoft that provides tools and libraries for building and running applications on various platforms, including Windows, macOS, Linux, and mobile devices. It supports multiple programming languages, such as C#, F#, and Visual Basic.

## 8. What is the .NET Standard?
.NET Standard is a specification that defines a set of APIs that all .NET implementations must follow. It allows developers to write libraries that can be used in different versions of .NET (such as .NET Core, .NET Framework, and Xamarin) without modification.

## 9. Explain what semantic versioning is
Semantic versioning is a software versioning system that uses a numbering scheme in the format MAJOR.MINOR.PATCH:
- **MAJOR**: Incremented for incompatible changes.
- **MINOR**: Incremented for compatible features added.
- **PATCH**: Incremented for compatible bug fixes.

## 10. What does LTS mean in the software version?
LTS (Long-Term Support) stands for Long-Term Support. LTS versions of software receive updates and support for an extended period, usually 3 years or more, guaranteeing stability and security for companies that depend on specific versions.

## 11. What is a Runtime?
Runtime refers to the environment in which the code executes. In the context of .NET, the runtime is the CLR, which provides the services needed to run and manage the code, including JIT compilation, garbage collection, and security.

## 12. What is an SDK?
An SDK (Software Development Kit) is a set of tools, libraries, documentation and examples that help developers create applications for a specific platform. The .NET SDK, for example, includes the compiler, runtime, and command-line tools for developing .NET applications.

## 13. What is a CLI?
CLI (Command Line Interface) is a text-based user interface that allows users to interact with software through commands typed into a terminal or command prompt. In .NET, the CLI is used to compile, run and manage projects.

## 14. Name 3 types of projects we have in .NET
- **Console Application**: Projects that produce command line applications.
- **Web Application**: Projects for developing web applications using ASP.NET.
- **Class Library**: Projects that create libraries of reusable classes that can be referenced by other projects.

## 15. What is a Solution?
A Solution is a container for one or more projects in Visual Studio. It allows you to manage, build and debug multiple projects together, making it easier to organize and develop complex applications that consist of several components.

## 16. Which command to run a .NET application?
To run a .NET application, use the command:

`
dotnet run
`

This command compiles the application (if necessary) and then runs it. It is especially useful during development, as it allows you to quickly test changes to the code. The `dotnet run` command looks for a project file (.csproj) or a solution (.sln) in the current directory and runs the specified application.

## 17. Which command to use to compile a .NET application?
To compile a .NET application, use the command:

```` 

dotnet build

```` 

This command compiles the project and all its dependencies, generating the binaries in the `bin` directory. The `dotnet build` command processes all the project files, generating the necessary assemblies. You can specify additional settings, such as the configuration (Debug or Release) and the target framework.

## 18. Which command to publish a .NET application?
To publish a .NET application, use the command:

```` 

dotnet publish

```` 

This command compiles the application and prepares the files for deployment in a production environment. It generates all the necessary files, including binaries and dependencies, in the `publish` directory. You can specify options such as the output directory, the configuration (Debug or Release) and the target runtime. Examples:

```` 

dotnet publish --configuration Release --output ./publish

```` 


## 19. What is the name of the main method of a Console App?
The main method of a Console App in C# is called `Main`. This method is the entry point of the application and must have one of the following signatures:

```` 

static void Main(string[] args)
static int Main(string[] args)
static void Main()
static int Main()

```` 

The `Main` method can return an integer to indicate an exit code for the operating system. The `string[] args` parameter allows you to pass command line arguments to the application.

## 20. What does Debug mean?
Debugging is the process of identifying and correcting errors or bugs in software. It involves the detailed inspection of the program's behavior during its execution. Debugging tools allow:
- **Breakpoints**: Pause execution at specific points in the code.
- **Watch**: Monitor the value of variables and expressions.
- **Step Over/Into**: Run the code line by line to understand the flow of execution.
- **Call Stack**: View the call stack to understand the execution sequence.

## 21. How do we run a .NET application in Debug mode?
To run a .NET application in Debug mode, you can use an integrated development environment (IDE) such as Visual Studio, where there is a specific button to start debugging (usually represented by a “play” icon with an insect). Alternatively, you can use the following command in a terminal, if you have set up a debugging profile:

```` 

dotnet run --configuration Debug

```` 

This command runs the application using the Debug configuration, which includes additional debugging information and does not optimize the code, making it easier to identify problems.

## 22. What is the purpose of the Properties folder?
The `Properties` folder in a .NET project usually contains project-specific configuration files. The most common file is `AssemblyInfo.cs`, which contains metadata about the assembly, such as version, copyright information and custom attributes. In ASP.NET applications, it can include `launchSettings.json`, which defines execution profiles and environment settings for debugging.

## 23. What is the purpose of the Bin and Obj folders?
- **Bin**: Contains the binaries (executables and DLLs) generated after compiling the project. Organized in subdirectories by configuration (Debug/Release) and target framework.
- **Object**: Contains temporary files used by the compilation process, such as intermediate object files, dependency caches and project metadata. Essential for the efficiency of the build process, as it stores information that can be reused in subsequent builds.

## 24. What parts make up a C# program?
A C# program is made up of:
- **Namespaces**: They logically group classes and other types to avoid name conflicts.
- **Classes and Interfaces**: Define types and contracts for objects.
- **Methods**: Perform actions and contain programming logic.
- **Properties and Fields**: Store data in classes.
- **Attributes and Events**: Provide additional information and allow interactions between objects.

## 25. What are Namespaces?
Namespaces are containers that provide a context for identifiers (class names, interfaces, etc.) in C#. They help organize large projects and avoid naming conflicts. For example:

```` 

namespace MyProject
{
    public class MyClass { }
}

```` 

The use of namespaces allows different parts of the code to use similar names without collision, as long as they are in different namespaces.

## 26. What is the purpose of Using?
The `using` directive in C# is used to:
- **Import namespaces**: Allows you to use types defined in other namespaces without having to write the full name of the namespace. Example:

```` 

using System;
Console.WriteLine(“Hello World”);

```` 

- **Resource management**: When used with objects that implement the `IDisposable` interface, it ensures that resources are released correctly. Example:

```` 

using (var resource = new Resource())
{
    // resource usage
}

```` 


## 27. What is the difference between a variable and a constant?
- **Variable**: A location in memory that can store data and whose value can be changed during program execution. Declared with the syntax:

```` 

int age = 30;

```` 

- **Constant**: A value that is set once and cannot be changed. Declared using the `const` keyword:

```` 

const int MaxTries = 5;

```` 


## 28. Name 3 reserved names we have in C#
Some reserved names in C# include:
- `abstract`: Used to declare abstract classes and methods.
- `base`: Used to access members of the base class.
- `catch`: Used to catch exceptions in a `try-catch` block.

## 29. What ways do we have to comment code in C#?
In C#, we can comment code in three ways:
- **Single line comment**: Using `//`. Example:

```` 

int x = 10; // This is a single-line comment

```` 

- **Block comment**: Using `/* ... */`. Example:

```` 

/* This is a
   block comment */

```` 

- **Documentation comment**: Using `///` to generate XML documentation. Example:

```` 

/// <summary>
/// This method does something.
/// </summary>
public void MyMethod() { }

```` 


## 30. What are primitive types?
Primitive types are basic data types provided by the language. In C#, they include:
- `int`: Integer numbers.
- `char`: Single character.
- `double`: Double precision floating point numbers.
- `bool`: Boolean values (true/false).

## 31. What is the base type in .NET?
The base type in .NET is `System.Object`. All classes and types in .NET derive, directly or indirectly, from `System.Object`. This means that all types, whether user-defined or primitive types, inherit fundamental methods, such as `ToString()`, `Equals()`, `GetHashCode()`, and `GetType()`.

## 32. Given a var of a real number, what type would the var be?
When we use `var` to declare a variable that is initialized with a real number, the type inferred by the compiler will be `double`, unless we use the suffix `f` or `m`:

```` 

var realNumber = 1.23; // inferred type is double
var realFloatNumber = 1.23f; // inferred type is float
var realDecimalNumber = 1.23m; // inferred type is decimal

```` 


## 33. Given a var of an integer, what type would the var be?
When we use `var` to declare a variable that is initialized with an integer, the type inferred by the compiler will be `int`:

```` 

var numberInteger = 123; // inferred type is int

```` 


## 34. What is the difference between char and string?
- **char**: Represents a single Unicode character and is declared using single quotes. Example:

```` 

char letter = 'A';

```` 

- **string**: Represents a sequence of Unicode characters and is declared using double quotes. Example:

```` 

string word = “Hello”;

```` 


## 35. What is the default value of the char type?
The default value of the `char` type is the null character, represented as `'\0'`.

## 36. What is the difference between var and object?
- **var**: Used for type inference at compile time. The exact type is determined by the compiler based on the initialization value. Example:

```` 

var text = “Hello”; // inferred type is string

```` 

- **object**: This is the base type for all types in .NET and can store any type of data. However, in order to use the value, it is usually necessary to perform a casting. Example:

```` 

object anything = “Hello”;
string text = (string)anything;

```` 


## 37. What are nullable types?
Nullable types are types that allow you to represent all the values of their base type plus one additional value: `null`. In C#, they are declared using `?`. Example:

```` 

int? number = null;

```` 

This is useful for representing data that may or may not be present.

## 38. What are aliases? Name 3 examples
Aliases are alternative names for types in C#. Some examples include:
- `int` for `System.Int32`
- `string` for `System.String`
- `bool` for `System.Boolean`

## 39. What are implicit conversions?
Implicit conversions are those that the compiler performs automatically, without the need for an explicit cast, usually because there is no risk of data loss. Examples include:

```` 

int number = 123;
double numberDouble = number; // implicit conversion from int to double

```` 


## 40. What are explicit conversions?
Explicit conversions require an explicit cast, usually because there is a risk of data loss or because the compiler cannot guarantee the safety of the conversion. Example:

```` 

double numberDouble = 123.45;
int number = (int)numberDouble; // explicit conversion from double to int

```` 


## 41 What is the difference between parse and Convert?
- **Parse**: Static methods in primitive type classes that convert strings into their corresponding types. They throw an exception if the conversion fails. Example:

```` 

int number = int.Parse(“123”);

```` 

- **Convert**: Methods that can convert various types to other types, including strings. Can handle null values and uses `IConvertible` for conversions between non-string types. Example:

```` 

int number = Convert.ToInt32(“123”);

```` 


## 42. What are arithmetic operators and which ones do we have in C#?
Arithmetic operators are used to perform basic mathematical operations. In C#, they include:
- `+` (addition)
- `-` (subtraction)
- `*` (multiplication)
- `/` (division)
- `%` (modulus)

## 43. What are assignment operators and which ones do we have in C#?
Assignment operators are used to assign values to variables. In C#, they include:
- `=` (simple assignment)
- `+=` (addition and assignment)
- `-=` (subtraction and assignment)
- `*=` (multiplication and assignment)
- `/=` (division and assignment)
- `%=` (modulus and assignment)

## 44. What are comparison operators and which ones do we have in C#?
Comparison operators are used to compare values. In C#, they include:
- `==` (equality)
- `!=` (difference)
- `>` (greater than)
- `<` (less than)
- `>=` (greater than or equal to)
- `<=` (less than or equal to)

## 45. What are logical operators and which ones do we have in C#?
Logical operators are used to perform logical operations on Boolean values. In C#, they include:
- `&&` (logical AND)
- `||` (logical OR)
- `!` (logical NOT)

## 46. Name two conditional structures we have in C#
Two conditional structures in C# are:
- **if/else**: Executes a block of code if a condition is true, and optionally another block if the condition is false.

```` 

if (condition)
{
    // code if the condition is true
}
else
{
    // code if condition is false
}

```` 

- **switch**: Selects a block of code to execute based on the value of an expression.

```` 

switch (expression)
{
    case value1:
        // code for value1
        break;
    case value2:
        // code for value2
        break;
    default:
        // default code
        break;
}

```` 


## 47. Name two repeating structures we have in C#
Two repetition structures in C# are:
- **for**: Iterates a block of code a specific number of times.

```` 

for (int i = 0; i < 10; i++)
{
    // code to be repeated
}

```` 

- **while**: Iterates a block of code while a condition is true.

```` 

while (condition)
{
    // code to be repeated
}

```` 


## 48. What is the difference between while and do/while?
The difference between `while` and `do/while` is:
- **while**: Checks the condition before executing the block of code.

```` 

while (condition)
{
    // code to be repeated
}

```` 

- **do/while**: Executes the code block at least once, then checks the condition.

```` 

do
{
    // code to be repeated
} while (condition);

```` 


## 49 How do we define that a method returns no value?
A method that returns no value is defined using the `void` keyword. Example:

```` 

public void MyMethod()
{
    // method code
}

```` 


## 50. Can we have methods without parameters in C#?
Yes, we can have methods without parameters in C#. Example:

```` 

public void MyMethod()
{
    // method code
}

```` 

## How do we make a parameter optional in C#?
To make a parameter optional in C#, you can provide a default value for the parameter in the method signature. Example:

```` 

public void MyMethod(int required, int optional = 10)
{
    // method code
}

```` 

In this example, the `optional` parameter has a default value of 10, so the method can be called with one or two arguments.

## 52. What are heap and stack?
- **Heap**: This is an area of memory used to store dynamically allocated objects. The allocation and deallocation of memory in the heap is managed by the Garbage Collector.
- **Stack**: This is a memory area used to store local variables and flow control information (such as return addresses). The stack follows the LIFO (Last In, First Out) model.

## 53. What are value types and reference types?
- **Value Types**: They store data directly and are allocated on the stack. Examples include `int`, `char`, and `structs`.
- **Reference Types**: Store a reference to a location in the heap where the actual data is stored. Examples include `class`, `interface`, `delegate`, and `arrays`.

## 54. Where are value types stored?
Value types are stored in the stack, where their lifetime and scope are well defined and limited to the block of code in which they are defined.

## 55. Where are reference types stored?
Reference types are stored in the heap, with the reference to this data stored in the stack. This allows objects to have a more flexible lifespan and can be shared between different parts of the code.

## 56. What are Structs?
Structs are value types that allow related variables to be grouped together in a single unit. They are useful for representing small sets of related data. Unlike classes, structs do not support inheritance, but they can implement interfaces.

```` 

public struct Point
{
    public int X;
    public int Y;
}

```` 


## 57. What are enumerators?
Enumerators (enums) are value types that consist of a set of named constants. They are used to represent a group of related values in a more readable way.

```` 

public enum WeekDays
{
    Sunday,
    Monday,
    Tuesday
    Wednesday
    Thursday
    Friday,
    Saturday
}

```` 


## 58. What is a GUID?
GUID (Globally Unique Identifier) is a globally unique identifier. In C#, it is represented by the structure `System.Guid` and is used to uniquely identify objects or records.

```` 

Guid id = Guid.NewGuid();

```` 


## 59. What is string interpolation?
String interpolation allows expressions to be inserted inside string literals. In C#, it is done using the `$` symbol before the string and `{}` to delimit the expressions.

```` 

int age = 30;
string message = $“I am {age} years old.”;

```` 


## 60. What is the purpose of the CompareTo method?
The `CompareTo` method is used to compare the current instance with another object of the same type and returns a value that indicates the relative order of the compared objects. Returns:
- **Less than zero**: If the current instance is smaller.
- **Zero**: If they are equal.
- **Greater than zero**: If the current instance is greater.

```` 

int result = x.CompareTo(y);

```` 


## 61. What is the purpose of the Contains method?
The `Contains` method is used to check whether a given substring is present within a string.

```` 

string text = “Hello, world!”;
bool contains = text.Contains(“world”);

```` 


## 62. What is the purpose of the StartsWith and EndsWith methods?
- **StartsWith**: Checks whether a string starts with a given substring.

```` 

string text = “Hello, world!”;
bool startsWith = text.StartsWith(“Hello”);

```` 

- **EndsWith**: Checks if a string ends with a given substring.

```` 

bool endsWithWorld = text.EndsWith(“world!”);

```` 


## 63 What is the purpose of the Equals method?
The `Equals` method is used to determine whether two instances of an object are equal. In C#, it is often overridden in classes to provide a specific comparison.

```` 

public override bool Equals(object obj)
{
    // implementation of the comparison
}

```` 


## 64. What is the purpose of the IndexOf and LastIndexOf methods?
- **IndexOf**: Returns the index of the first occurrence of a substring within a string.

```` 

string text = “Hello, world!”;
int index = text.IndexOf(“world”);

```` 

- **LastIndexOf**: Returns the index of the last occurrence of a substring within a string.

```` 

int lastIndex = text.LastIndexOf(“the”);

```` 


## 65. What is the purpose of the ToLower and ToUpper methods?
- **ToLower**: Converts all characters in a string to lower case.

```` 

string text = “Hello, World!”;
string textMinuscle = text.ToLower();

```` 

- **ToUpper**: Converts all characters in a string to upper case.

```` 

string textMinuscle = text.ToUpper();

```` 


## 66. What is the purpose of the Insert method?
The `Insert` method inserts a substring at a specific position within a string.

```` 

string text = “Hello, world!”;
string newText = text.Insert(4, “dear ”);

```` 

In this example, “dear” is inserted in position 4 of the original string.

## 67. What is the purpose of the Length method?
The `Length` property returns the number of characters in a string.

```` 

string text = “Hello, world!”;
int length = text.Length;

```` 


## 68. What is the purpose of the Remove method?
The `Remove` method removes a part of a string, starting at a specified index.

```` 

string text = “Hello, world!”;
string newText = text.Remove(4, 7);

```` 

In this example, starting at index 4, 7 characters are removed.

## 69. What is the purpose of the Replace method?
The `Replace` method replaces all occurrences of a substring with another.

```` 

string text = “Hello, world!”;
string newText = text.Replace(“world”, “friend”);

```` 


## 70. What is the purpose of the Split method?
The `Split` method splits a string into an array of substrings based on specified delimiters.

```` 

string text = “Hello, world!”;
string[] words = text.Split(' ');

```` 


## 71 What is the purpose of the Substring method?
The `Substring` method returns a new string which is a part of the original string, starting at a specified index.

```` 

string text = “Hello, world!”;
string newString = text.Substring(4, 5);

```` 


## 72. What is the purpose of the Trim method?
The `Trim` method removes all whitespace from the beginning and end of a string.

```` 

string text = “ Hello, world!  ";
string textTrimmed = text.Trim();

```` 


## 73. What is StringBuilder and when should we use it?
`StringBuilder` is a class used to dynamically manipulate strings efficiently, especially when several modifications are required. Unlike strings, which are immutable, `StringBuilder` allows you to modify their content without creating new objects.

```` 

StringBuilder sb = new StringBuilder();
sb.Append(“Hello”);
sb.Append(“, world!”);
string result = sb.ToString();

```` 

Use `StringBuilder` when performing many concatenation operations to avoid the overhead of creating multiple instances of strings.

## 74. What is Regex and when should we use it?
`Regex` (Regular Expression) is a class used to perform pattern matching operations on strings, such as search, replace and validation. It is useful for validating complex input formats, such as e-mail addresses and telephone numbers.

```` 

using System.Text.RegularExpressions;

string pattern = @“^\d{4}-\d{2}-\d{2}$”;
string date = “2024-06-06”;
bool isMatch = Regex.IsMatch(date, pattern);

```` 


## 75. What is DateTime?
`DateTime` is a structure that represents specific instants in time, usually expressed as a date and time of day. It offers various methods for manipulating and formatting dates and times.

```` 

DateTime now = DateTime.Now;
DateTime dateSpecifies = new DateTime(2024, 6, 6);

```` 


## 76. How do we get today's date in C#?
To get today's date in C#, use the `DateTime.Now` property:

```` 

DateTime today = DateTime.Now;

```` 

If you just want the date without the time, use:

```` 

DateTime today = DateTime.Today;

```` 


## 77. How do we convert a date to a string?
To convert a date to a string, use the `ToString` method of the `DateTime` class with a specific format, if desired.

```` 

DateTime today = DateTime.Now;
string dateString = today.ToString(“yyyy-MM-dd”);

```` 


## 78. How do we compare two dates in C#?
To compare two dates, you can use the comparison operators (`<`, `>`, `<=`, `>=`) or the `Compare` and `CompareTo` methods.

```` 

DateTime date1 = new DateTime(2024, 6, 6);
DateTime date2 = DateTime.Now;

int compare = DateTime.Compare(date1, date2);

if (compare < 0)
{
    Console.WriteLine(“date1 is earlier than date2”);
}
else if (compare == 0)
{
    Console.WriteLine(“date1 is equal to date2”);
}
else
{
    Console.WriteLine(“date1 is later than date2”);
}

```` 


## 79. How can we get the year, month or day in C#?
To get the year, month or day of a `DateTime` object, use the `Year`, `Month` and `Day` properties:

```` 

DateTime today = DateTime.Now;
int year = today.Year;
int month = today.Month;
int day = today.Day;

```` 


## 80. How can we get the last day of the month in C#?
To get the last day of the month, you can use the `DateTime.DaysInMonth` method to find the number of days in a specific month and then create a date with that value.

```` 

int year = 2024;
int month = 6;
int lastDay = DateTime.DaysInMonth(year, month);
DateTime lastDay = new DateTime(year, month, lastDay);

```` 


## 81 Can we create null dates?
Yes, we can create null dates using nullable types with `DateTime?`.

```` 

DateTime? dateNull = null;

```` 


## 82. What are nullable types?
Nullable types allow value types (such as `int`, `bool`, `DateTime`) to store a null value (`null`) in addition to their normal values. They are declared using `?`.

```` 

int? numberNulo = null;

```` 


## 83. What is Timezone?
Timezone represents the time difference between a specific location and Coordinated Universal Time (UTC). `TimeZoneInfo` is the class in C# that provides information about timezones.

```` 

TimeZoneInfo timezone = TimeZoneInfo.Local;

```` 


## 84. How do we get the date without a Timezone in C#?
To get a date without a specific time zone, use the `DateTime` structure without any conversion to time zones:

```` 

DateTime date = DateTime.Now;

```` 


## 85. What is DateTime Offset?
`DateTimeOffset` is a structure that represents a date and time with an offset from UTC. It is useful for storing and manipulating dates and times in different time zones.

```` 

DateTimeOffset now = DateTimeOffset.Now;

```` 


## 86. What is a TimeSpan?
A `TimeSpan` is a structure that represents a time interval. It can be used to store durations or calculate the difference between two dates.

```` 

TimeSpan duration = new TimeSpan(1, 30, 0); // 1 hour and 30 minutes

```` 


## 87. What is the purpose of Math.Round, Math.Celling and Math.Floor?
- **Math.Round**: Rounds a number to the nearest integer.

```` 

double value = 3.56;
double round = Math.Round(value); // 4

```` 

- **Math.Ceiling**: Rounds a number to the next larger integer.

```` 

double value = 3.56;
double roundedUp = Math.Ceiling(value); // 4

```` 

- **Math.Floor**: Rounds a number to the next smaller integer.

```` 

double value = 3.56;
double roundedLow = Math.Floor(value); // 3

```` 


## 88. What is the difference between IEnumerable, IList and ICollection?
- **IEnumerable**: Basic interface for iterating over a collection. Only allows sequential reading.

```` 

IEnumerable<int> numbers = new List<int> { 1, 2, 3 };
foreach (int num in numbers)
{
    Console.WriteLine(num);
}

```` 

- **ICollection**: Inherits from `IEnumerable` and adds support for counting items, adding and removing items.

```` 

ICollection<int> collection = new List<int> { 1, 2, 3 };
int count = collection.Count;

```` 

- **IList**: Inherits from `ICollection` and adds support for indexed access and insertion/removal of items in specific positions.

```` 

IList<int> list = new List<int> { 1, 2, 3 };
int firstItem = list[0];
list.Insert(1, 4);

```` 


## 89. What is the difference between List and IList?
- **List<T>**: This is a concrete implementation of the `IList<T>` interface provided by the .NET Framework. Used to store collections of data that can be accessed by index and manipulated in various ways.
- **IList<T>**: This is an interface that defines indexed list operations. `List<T>` is just one of the possible implementations of this interface.

```` 

List<int> myList = new List<int> { 1, 2, 3 };
IList<int> listInterface = myList;

```` 


## 90. What is the purpose of the Add and AddRange methods in a list?
- **Add**: Adds a single element to the end of the list.

```` 

List<int> list = new List<int>();
list.Add(1);

```` 

- **AddRange**: Adds a collection of elements to the end of the list.

```` 

List<int> list = new List<int>();
list.AddRange(new int[] { 2, 3, 4 });

```` 


## 91. What is the purpose of the Clear method in a list?
The `Clear` method removes all the elements from the list, leaving it empty.

```` 

List<int> list = new List<int> { 1, 2, 3 };
list.Clear(); // list is now empty

```` 


## 92. What is the purpose of the Contains method in a list?
The `Contains` method checks whether a specific element is present in the list.

```` 

List<int> list = new List<int> { 1, 2, 3 };
bool contains = list.Contains(2); // true

```` 


## 93. What is the purpose of the CopyTo method in a list?
The `CopyTo` method copies the elements of the list into a one-dimensional array, starting at a specified index of the destination array.

```` 

List<int> list = new List<int> { 1, 2, 3 };
int[] array = new int[5];
list.CopyTo(array, 1); // array now contains [0, 1, 2, 3, 0]

```` 


## 94. What is the purpose of the Exists method in a list?
The `Exists` method checks whether any element in the list corresponds to a specified predicate.

```` 

List<int> list = new List<int> { 1, 2, 3 };
bool exists = list.Exists(x => x > 2); // true

```` 


## 95. What is the purpose of the Find and FindAll methods in a list?
- **Find**: Returns the first element that matches the specified predicate.

```` 

List<int> list = new List<int> { 1, 2, 3, 4 };
int found = list.Find(x => x > 2); // 3

```` 

- **FindAll**: Returns all the elements that match the specified predicate.

```` 

List<int> list = new List<int> { 1, 2, 3, 4 };
List<int> found = list.FindAll(x => x > 2); // [3, 4]

```` 


## 96. What is the purpose of the IndexOf and LastIndexOf methods in a list?
- **IndexOf**: Returns the index of the first occurrence of a specified element.

```` 

List<int> list = new List<int> { 1, 2, 3, 2 };
int index = list.IndexOf(2); // 1

```` 

- **LastIndexOf**: Returns the index of the last occurrence of a specified element.

```` 

int lastIndex = list.LastIndexOf(2); // 3

```` 


## 97. What is the purpose of the FindIndex, FindLast and FindLastIndex methods in a list?
- **FindIndex**: Returns the index of the first element that matches the specified predicate.

```` 

List<int> list = new List<int> { 1, 2, 3, 4 };
int index = list.FindIndex(x => x > 2); // 2

```` 

- **FindLast**: Returns the last element that matches the specified predicate.

```` 

int lastFound = list.FindLast(x => x > 2); // 4

```` 

- **FindLastIndex**: Returns the index of the last element matching the specified predicate.

```` 

int lastIndex = list.FindLastIndex(x => x > 2); // 3

```` 


## 98. What is the purpose of the Insert and InsertRange methods in a list?
- **Insert**: Inserts an element into the list at the specified position.

```` 

List<int> list = new List<int> { 1, 2, 3 };
list.Insert(1, 4); // list now contains [1, 4, 2, 3]

```` 

- **InsertRange**: Inserts a collection of elements into the list, starting at the specified position.

```` 

List<int> list = new List<int> { 1, 2, 3 };
list.InsertRange(1, new int[] { 5, 6 }); // list now contains [1, 5, 6, 2, 3]

```` 


## 99. What is the purpose of the Remove, RemoveAll, RemoveAt and RemoveRange methods in a list?
- **Remove**: Removes the first occurrence of a specified element.

```` 

List<int> list = new List<int> { 1, 2, 3, 2 };
list.Remove(2); // list now contains [1, 3, 2]

```` 

- **RemoveAll**: Removes all elements that match the specified predicate.

```` 

list.RemoveAll(x => x > 2); // list now contains [1, 2]

```` 

- **RemoveAt**: Removes the element at the specified position.

```` 

list.RemoveAt(1); // list now contains [1, 3]

```` 

- **RemoveRange**: Removes a specified number of elements, starting at the specified position.

```` 

list.RemoveRange(1, 2); // list now contains [1]

```` 


## 100. What is the purpose of the Reverse method in a list?
The `Reverse` method reverses the order of the elements in the list.

```` 

List<int> list = new List<int> { 1, 2, 3 };
list.Reverse(); // list now contains [3, 2, 1]

```` 


## 101. What is the purpose of the Sort method in a list?
The `Sort` method sorts the elements of the list in ascending order.

```` 

List<int> list = new List<int> { 3, 1, 2 };
list.Sort(); // list now contains [1, 2, 3]

```` 


## 102. What is the purpose of the ToArray method in a list?
The `ToArray` method converts the list into an array.

```` 

List<int> list = new List<int> { 1, 2, 3 };
int[] array = list.ToArray();

```` 


## 103. What is the purpose of the TrueForAll method in a list?
The `TrueForAll` method checks that all the elements in the list meet a specified predicate.

```` 

List<int> list = new List<int> { 2, 4, 6 };
bool allPars = list.TrueForAll(x => x % 2 == 0); // true

```` 


## 104. What is the purpose of the ConvertAll method in a list?
The `ConvertAll` method converts all the elements in the list to a new type by applying a conversion function to each element.

```` 

List<int> list = new List<int> { 1, 2, 3 };
List<string> strings = list.ConvertAll(x => x.ToString());

```` 


## 105 What is the purpose of the ForEach method in a list?
The `ForEach` method performs a specific action on each element in the list.

```` 

List<int> list = new List<int> { 1, 2, 3 };
list.ForEach(x => Console.WriteLine(x));

```` 


## 106. What is the purpose of the Where method in a list?
The `Where` method filters the elements of the list based on a specified predicate, returning a new collection containing only the elements that satisfy the predicate.

```` 

List<int> list = new List<int> { 1, 2, 3, 4 };
IEnumerable<int> pairs = list.Where(x => x % 2 == 0); // [2, 4]

```` 


## 107. What is the purpose of the First method in a list?
The `First` method returns the first element in the list that satisfies a specified predicate. It throws an exception if no element is found.

```` 

List<int> list = new List<int> { 1, 2, 3, 4 };
int firstPar = list.First(x => x % 2 == 0); // 2

```` 


## 108. What is the purpose of the OrderBy method in a list?
The `OrderBy` method sorts the elements of the list in ascending order based on a specified key.

```` 

List<int> list = new List<int> { 3, 1, 4, 2 };
IEnumerable<int> ordered = list.OrderBy(x => x); // [1, 2, 3, 4]

```` 


## 109. What is the purpose of the Sort method in a list?
The `Sort` method sorts the elements of the list in ascending order.

```` 

List<int> list = new List<int> { 3, 1, 2 };
list.Sort(); // list now contains [1, 2, 3]

```` 


## 110. What is the purpose of the Select method in a list?
The `Select` method projects each element of a collection into a new form, applying a transformation function to each element.

```` 

List<int> list = new List<int> { 1, 2, 3 };
IEnumerable<string> strings = list.Select(x => x.ToString()); // [“1”, “2”, “3”]

```` 

## 111. What is the purpose of the method Converting Lists into a list?
I assume that “Converting Lists” refers to using the `ConvertAll` method to convert all the elements in a list to another type. This method is useful for transforming a list of one type into a list of another type.

```` 

List<int> list = new List<int> { 1, 2, 3 };
List<string> strings = list.ConvertAll(x => x.ToString());

```` 


## 112. What are Classes and Objects?
- Classes are definitions of data types that encapsulate data and methods that operate on that data. A class is a blueprint from which objects are created.

```` 

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

```` 

- Objects are instances of classes. They contain concrete values and have behavior defined by the classes.

```` 

Person person = new Person { Name = “John”, Age = 30 };

```` 


## 113. What is an instance?
An instance is a concrete object created from a class. Creating an instance of a class is the process of allocating memory and initializing an object of that class.

```` 

Person person = new Person();

```` 


## 114. What are Properties?
Properties are members of a class that provide a flexible mechanism for reading, writing or calculating the value of a particular field. They are used like public fields, but with additional control.

```` 

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

```` 


## 115. What are constructor methods?
Constructor methods are special methods of a class that are called when a new instance of the class is created. They are used to initialize objects.

```` 

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    // Constructor
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}

```` 


## 116. What is the Garbage Collector?
The Garbage Collector (GC) is an automatic memory management mechanism in .NET that recovers memory allocated by objects that are no longer needed by the program. It performs garbage collection, which is the process of identifying and freeing memory used by objects that no longer have active references.

## 117. What is Object Dispose?
`Dispose` is a method of the `IDisposable` interface used to free resources that are not explicitly managed, such as database connections, files, etc. Implementing `Dispose` allows you to release these resources deterministically.

```` 

public class Resource : IDisposable
{
    public void Dispose()
    {
        // Release resources
    }
}

```` 


## 118. Define the public, private and protected modifiers
- **public**: The member is accessible from anywhere.

```` 

public class MyClass
{
    public int MyField;
}

```` 

- **Private**: The member is accessible only within the class in which it was declared.

```` 

public class MyClass
{
    private int MyField;
}

```` 

- **Protected**: The member is accessible within the class in which it was declared and in derived classes.

```` 

public class MyClass
{
    protected int MyField;
}

```` 


## 119. What are static objects?
Static objects are instances of classes that are unique in the context of the application. Static members are shared by all instances of the class and can be accessed directly by the class without creating an object.

```` 

public class MyClass
{
    public static int Counter;
}

```` 


## 120. What is Inheritance?
Inheritance is a principle of object-oriented programming that allows a class (derived class) to inherit members (fields, properties, methods) from another class (base class). This promotes code reuse.

```` 

public class Animal
{
    public void Comer() { }
}

public class Puppy : Animal
{
    public void Bark() { }
}

```` 


## 121. What is Upcast and Downcast?
- **Upcast**: Converting an object from a derived class to a base class. It is implicit and safe.

```` 

Puppy puppy = new Puppy();
Animal animal = dog; // Upcast

```` 

- **Downcast**: Convert an object from a base class to a derived class. It is explicit and can throw exceptions if the type is not compatible.

```` 

Animal animal = new Puppy();
Puppy puppy = (Puppy)animal; // Downcast

```` 


## 122. What are Interfaces?
Interfaces are contracts that define a set of methods and properties that a class must implement. They do not contain code implementation, only the signature of the members.

```` 

public interface IAnimal
{
    void Comer();
}

public class Puppy : IAnimal
{
    public void Eat() { }
}

```` 


## 123. What are abstract classes?
Abstract classes are classes that cannot be instantiated directly and can contain abstract methods (without implementation) and concrete methods (with implementation). They are used to provide a basis for other classes.

```` 

public abstract class Animal
{
    public abstract void Comer();
}

public class Puppy : Animal
{
    public override void Eat() { }
}

```` 


## 124. What is the purpose of sealed classes?
Sealed classes are classes that cannot be inherited. Using `sealed` in a class can improve performance, as the compiler can make optimizations.

```` 

public sealed class MySealedClass
{
    // Implementation
}

```` 


## 125. What is method overloading?
Method overloading allows you to define multiple methods with the same name but different signatures (different types or number of parameters) within the same class.

```` 

public class MyClass
{
    public void Method(int x) { }
    public void Method(string x) { }
}

```` 


## 126. What is method overwriting?
Method overriding allows a derived class to provide a specific implementation of a method that is already defined in the base class. The `override` keyword is used.

```` 

public class Animal
{
    public virtual void MakeSound() { }
}

public class Puppy : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine(“Bark”);
    }
}

```` 


## 127. How can we Compare two objects in C#?
To compare two objects in C#, you can use the `Equals` method or overload the equality operators (`==` and `!=`). It is also common to implement the `IComparable` interface to provide a natural order of comparison.

```` 

public class Person : IComparable<Person>
{
    public string Name { get; set; }
    public int CompareTo(Person other)
    {
        return this.Name.CompareTo(other.Name);
    }
}

```` 


## 128. What is the purpose of Dispose?
The `Dispose` method of the `IDisposable` interface is used to release unmanaged resources, such as database connections, files, etc. It is implemented to ensure that these resources are released deterministically.

```` 

public class Resource : IDisposable
{
    public void Dispose()
    {
        // Release resources
    }
}

```` 


## 129. What is Encapsulation?
Encapsulation is one of the principles of object-oriented programming that consists of hiding the internal details of a class and exposing only what is necessary through public methods and properties. This improves the modularity and maintainability of the code.

```` 

public class Person
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}

```` 


## 130. What is polymorphism?
Polymorphism is the ability to treat objects of different types in a uniform way. This is achieved through inheritance and interfaces, allowing methods in derived classes to be called via a reference to the base class or interface.

```` 

public class Animal
{
    public virtual void FazerSom() { }
}

public class Puppy : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine(“Bark”);
    }
}

Animal myAnimal = new Dog();
myAnimal.MakeSound(); // Output: Bark

```` 


## 131. What are complex types?
Complex types are data types that can be composed of primitive types and other complex types. In C#, these include classes, structs, arrays, collections and other user-defined types.

```` 

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
}

public class Person
{
    public string Name { get; set; }
    public Address Address { get; set; }
}

```` 


## 132. What are Delegates?
Delegates are types that represent references to methods with a specific signature. They allow you to treat methods as objects and pass methods as parameters to other methods.

```` 

public delegate void MeuDelegate(string message);

public class ExemploDelegate
{
    public void MethodWithDelegate(MyDelegate myDelegate)
    {
        myDelegate(“Hello, world!”);
    }
}

```` 


## 133. What are events?
Events are members of a class that allow the class or object to notify other classes or objects when something happens. Events are based on delegates and are used to implement the observer pattern.

```` 

public class Publisher
{
    public event EventHandler MyEvent;

    protected virtual void OnMyEvent()
    {
        MyEvent?.Invoke(this, EventArgs.Empty);
    }

    public void FireEvent()
    {
        OnMyEvent();
    }
}

```` 


## 134. What is the difference between Events and Delegates?
- **Delegates** are method pointers that can reference one or more methods with a specific signature. They can be invoked directly.
- **Events** are a safe way of exposing delegates. They provide a mechanism for event notification, allowing classes that trigger events not to be directly handled by subscribers. Events can only be invoked within the class where they are declared.

## 135. What are generics?
Generics allow classes, interfaces and methods to operate on types specified by the client of the code without compromising type safety. They allow the creation of reusable components that can work with any type of data.

```` 

public class ListaGenerica<T>
{
    private T[] elements;
    public void Add(T element) { }
}

```` 


## 136. How do we restrict a generic type?
We restrict a generic type using constraints, which specify the requirements that a type must satisfy in order to be used as a type argument. Examples of constraints include `where T : class`, `where T : struct`, and `where T : new()`.

```` 

public class MyGenericClass<T> where T : class
{
    private T element;
    public void SetElement(T element) { this.element = element; }
}

```` 


## 137. How do we handle errors in C#?
We handle errors in C# using `try-catch-finally` blocks. The `try` block contains code that can throw exceptions, the `catch` block handles exceptions, and the `finally` block contains code that must be executed regardless of whether an exception is thrown or not.

```` 

try
{
    // Code that can throw exceptions
}
catch (Exception ex)
{
    // Code to handle the exception
}
finally
{
    // Code that will always be executed
}

```` 


## 138. What is the purpose of finally?
The `finally` block is used to execute code that must be executed regardless of whether an exception is thrown or not. It is generally used to release resources or perform other cleanup tasks.

```` 

try
{
    // Code that can throw exceptions
}
catch (Exception ex)
{
    // Code to handle the exception
}
finally
{
    // Code that will always be executed
}

```` 


## 139. What is Try/Parse for?
The `TryParse` method is used to convert strings into numeric or date/time data types, returning a Boolean value that indicates whether the conversion was successful, without throwing exceptions in case of failure.

```` 

int number;
bool success = int.TryParse(“123”, out numero);

```` 


## 140. What are Tasks?
Tasks are asynchronous representations of units of work that can be executed in parallel. They are used for asynchronous operations and multithreading.

```` 

Task myTask = Task.Run(() => 
{
    // Code to run
});
await myTask;

```` 


## 141. What is async/await for?
`async` and `await` are used to simplify asynchronous programming. The `async` modifier indicates that a method contains asynchronous code, while `await` is used to pause the execution of an asynchronous method until a `Task` is completed.

```` 

public async Task MyMethodAsync()
{
    await Task.Delay(1000);
    Console.WriteLine(“Done”);
}

```` 


## 142. What is the difference between Task.FromResult and the use of await?
- **Task.FromResult**: Creates a `Task` that is completed immediately with a specified result. It is useful for creating asynchronous methods that return results immediately.

```` 

Task<int> result = Task.FromResult(42);

```` 

- **await**: Pauses execution of the asynchronous method until the `Task` is completed, allowing the method to continue executing asynchronously.

```` 

await Task.Delay(1000);

```` 


## 143. What do we use the IEquatable interface for?
The `IEquatable<T>` interface is used to define a type-specific comparison method. Implementing `IEquatable<T>` allows you to compare objects more efficiently and is especially useful in generic collections.

```` 

public class Person : IEquatable<Person>
{
    public string Name { get; set; }
    public bool Equals(Person other)
    {
        return this.Name == other.Name;
    }
}

```` 


## 144. What do we use the IComparable interface for?
The `IComparable<T>` interface is used to define a natural order of comparison for a type. Implementing `IComparable<T>` allows you to use objects of this type in sorting operations.

```` 

public class Person : IComparable<Person>
{
    public string Name { get; set; }
    public int CompareTo(Person other)
    {
        return this.Name.CompareTo(other.Name);
    }
}

```` 


## 145. When do we use the IDisposable interface?
We use the `IDisposable` interface to release unmanaged resources, such as files, network connections and database connections. Implementing `IDisposable` ensures that these resources are released deterministically.

```` 

public class Resource : IDisposable
{
    public void Dispose()
    {
        // Release resources
    }
}

```` 


## 146. What are Extension methods?
Extension methods are methods that allow you to add new functionality to existing types without modifying the original definition of the type. They are defined in static methods and are called as if they were instance methods.

```` 

public static class ExtensionMethods
{
    public static void MyExtensionMethod(this string str)
    {
        Console.WriteLine(str);
    }
}

// Usage
“Hello, world!”.MyExtensionMethod();

```` 
